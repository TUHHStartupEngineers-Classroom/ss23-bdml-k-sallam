{
  "hash": "caf0a949904251da44495e2985a9fb82",
  "result": {
    "markdown": "---\ntitle: \"04 Performance Measures\"\ndate: '2023-06-08'\n\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    collapsed: false\n    number_sections: true\n    toc_depth: 3\n    code_folding: hide\n---\n\n\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-1_3a18ffbc0cdc5565cc263b9ce810e187'}\n\n```{.r .cell-code}\n# install.packages(\"plotly\")\nlibrary(tidyverse)\nlibrary(tidyquant)\nlibrary(broom)\nlibrary(umap)\nlibrary(readxl)\nlibrary(h2o)\nlibrary(readxl)\nlibrary(rsample)\nlibrary(recipes)\nlibrary(PerformanceAnalytics)\nlibrary(h2o)\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-2_ed32ffb138ee692d9a28c6c3fafca2c6'}\n\n```{.r .cell-code}\nproduct_backorders_tbl <- read_csv(\"product_backorders.csv\")\n\n# Split into test and train\nset.seed(seed = 1113)\nsplit_obj <- rsample::initial_split(product_backorders_tbl, prop = 0.85)\n\n\n# Assign training and test data\ntrain_readable_tbl<- training(split_obj)\ntest_readable_tbl <- testing(split_obj)\n\n\n  recipe_obj <- recipe( went_on_backorder~., data = train_readable_tbl) %>% \n  step_zv(all_predictors()) %>%\n  prep()\n  \ntrain_tbl <- bake(recipe_obj, new_data = train_readable_tbl)\ntest_tbl  <- bake(recipe_obj, new_data = test_readable_tbl)\n\n #set the predictor names\n predictors <- c(\"national_inv\", \"lead_time\", \"forecast_3_month\", \"sales_3_month\")\n  \n# #specify the response\n response <- \"went_on_backorder\"\n\n \n\n h2o.init()\n # Split data into a training and a validation data frame\n # Setting the seed is just for reproducability\n split_h2o <- h2o.splitFrame(as.h2o(train_tbl), ratios = c(0.85), seed = 1234)\n train_h2o <- split_h2o[[1]]\n valid_h2o <- split_h2o[[2]]\n test_h2o  <- as.h2o(test_tbl)\n \n # Set the target and predictors\n y <- response\n x <- setdiff(names(train_h2o), y)\n \n ?h2o.automl\n \n automl_models_h2o <- h2o.automl(\n   x = x,\n   y = y,\n   training_frame    = train_h2o,\n   validation_frame  = valid_h2o,\n   leaderboard_frame = test_h2o,\n   max_runtime_secs  = 15,\n   nfolds            = 5 \n )\n\n\n\nleaderboard_Model <- automl_models_h2o@leaderboard\n\n \n Model<-automl_models_h2o@leader\n \n \n   h2o.saveModel(Model,path = \"ml_journal-KhaledSallam\")\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-3_5248c3673ccc0b9f2486ab410b9120ea'}\n\n```{.r .cell-code}\n# Leader board Visualization\nautoml_models_h2o@leaderboard %>% \n              as_tibble() %>% \n              select(-c(mean_per_class_error, rmse, mse))\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-4_902dda29d7ddc12814e0cc0810bf4749'}\n\n```{.r .cell-code}\n# data preparation and Visulatization\n\ndata_transformed_tbl <- automl_models_h2o@leaderboard %>%\n  as_tibble() %>%\n  select(-c(aucpr, mean_per_class_error, rmse, mse)) %>%\n  mutate(model_type = str_extract(model_id, \"[^_]+\")) %>%\n  slice(1:15) %>% \n  rownames_to_column(var = \"rowname\") %>%\n  \n  mutate(\n  model_id   = as_factor(model_id) %>% reorder(auc),\n  model_type = as.factor(model_type) \n  ) %>%\n  \n  pivot_longer(cols = -c(model_id, model_type, rowname),\n                       names_to = \"key\",\n                       values_to = \"value\",\n                       names_transform = list(key = forcats::fct_inorder)\n                       ) %>%\n        mutate(model_id = paste0(rowname, \". \", model_id) %>% as_factor() %>% fct_rev())\n\n# Final tibble to visualize\n\ndata_transformed_tbl\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-5_b48509bad7d4252ca245c6e6e1220a92'}\n\n```{.r .cell-code}\n## Visualization\n\ndata_transformed_tbl %>%\n        ggplot(aes(value, model_id, color = model_type)) +\n        geom_point(size = 3) +\n        geom_label(aes(label = round(value, 2), hjust = \"inward\")) +\n        \n        # Facet to break out logloss and auc\n        facet_wrap(~ key, scales = \"free_x\") +\n        labs(title = \"Leaderboard Metrics\",\n             subtitle = paste0(\"Ordered by: \", \"auc\"),\n             y = \"Model Postion, Model ID\", x = \"\") + \n        theme(legend.position = \"bottom\")\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-6_4e5f4a3853f0bea2ce80c3a5d083178d'}\n\n```{.r .cell-code}\n# Grid Search\n\ngrid_search_model <- h2o.loadModel(\"D:/GitHub/ss23-bdml-k-sallam/ml_journal-KhaledSallam/StackedEnsemble_AllModels_AutoML_20210105_234211\")\n\ngrid_search_model\ntest_tbl\n\n# test performance with new data output from previous test\n\nh2o.performance(grid_search_model, newdata = as.h2o(test_tbl))\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-7_cc9f49ec48c7f78944c487c05fe70e74'}\n\n```{.r .cell-code}\n# Grid Search\n\nsearch_grid_01 <- h2o.grid(\n  algorithm = \"deeplearning\",\n  grid_id = \"search_grid_01\",\n x = x,\n    y = y,\n    \n    # training and validation frame and crossfold validation\n    training_frame   = train_h2o,\n    validation_frame = valid_h2o,\n    nfolds = 5,\n    \n    # Hyperparamters: Use deeplearning_h2o@allparameters to see all\n    hyper_params = list(\n        # Use some combinations (the first one was the original)\n        hidden = list(c(10, 10, 10), c(50, 20, 10), c(20, 20, 20)),\n        epochs = c(10, 50, 20)\n    )\n)\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-8_9a55f1dee2bf44175c7a13055b6e5c2e'}\n\n```{.r .cell-code}\nsearch_grid_01\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-9_5dbda774d0fcf03baecda3ac50f05380'}\n\n```{.r .cell-code}\n# sort accoding to auc high to low\nh2o.getGrid(grid_id = \"search_grid_01\", sort_by = \"auc\", decreasing = TRUE)\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-10_e4289d153dab1a38f6804286630ef831'}\n\n```{.r .cell-code}\nsearch_grid_01_model_1 <- h2o.getModel(\"search_grid_01_model_1\")\nsearch_grid_01_model_1 %>% h2o.auc(train = T, valid = T, xval = T)\n\nsearch_grid_01_model_1 %>%\n    h2o.performance(newdata = as.h2o(test_tbl))\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-11_a84c36c0ce8599ce559f971c354e9545'}\n\n```{.r .cell-code}\n# H2o Performance\n\n#load model\nstacked_ensemble_h2o <- h2o.loadModel(\"D:/GitHub/ss23-bdml-ksallam/StackedEnsemble_AllModels_AutoML_20210105_234211\")\n\nperformance_h2o <- h2o.performance(stacked_ensemble_h2o, newdata = as.h2o(test_tbl))\n\ntypeof(performance_h2o)\nperformance_h2o %>% slotNames()\n\nperformance_h2o@metrics\n\n# Classifier Summary Metrics\n\nh2o.auc(performance_h2o, train = T, valid = T, xval = T)\n# our value is [1] 0.9037603\n\nh2o.auc(stacked_ensemble_h2o, train = T, valid = T, xval = T)\n#     train     valid      xval\n# 0.9320589 0.8932458 0.8576325\n\nh2o.giniCoef(performance_h2o)\n# [1] 0.8075205\n\nh2o.logloss(performance_h2o)\n# [1] 0.2362433\n\n# result for the training data\nh2o.confusionMatrix(stacked_ensemble_h2o)\n# Confusion Matrix (vertical: actual; across: predicted)  for max f1 @ threshold = 0.268791256959701\n\n# result for the hold out set\nh2o.confusionMatrix(performance_h2o)\n# Confusion Matrix (vertical: actual; across: predicted)  for max f1 @ threshold = 0.25817823725732\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-12_ad9385bbcd7cf379311fca88cd72e142'}\n\n```{.r .cell-code}\nperformance_tbl <- performance_h2o %>%\n    h2o.metric() %>%\n    as.tibble() \n\nperformance_tbl %>% \n  glimpse()\n\n# save our theme \ntheme_new <- theme(\n      legend.position  = \"bottom\",\n      legend.key       = element_blank(),\n      panel.background = element_rect(fill   = \"transparent\"),\n      panel.border     = element_rect(color = \"black\", fill = NA, size = 0.5),\n      panel.grid.major = element_line(color = \"grey\", size = 0.333)\n      ) \n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-13_353abfa7b7181489481f87c121c8b95d'}\n\n```{.r .cell-code}\n# Visualize the trade of between the precision and the recall and the optimal threshold\n\nperformance_tbl %>%\n    filter(f1 == max(f1))\n\nperformance_tbl %>%\n    ggplot(aes(x = threshold)) +\n    geom_line(aes(y = precision), color = \"blue\", size = 1) +\n    geom_line(aes(y = recall), color = \"red\", size = 1) +\n    \n    # Insert line where precision and recall are harmonically optimized\n    geom_vline(xintercept = h2o.find_threshold_by_max_metric(performance_h2o, \"f1\")) +\n    labs(title = \"Precision vs Recall\", y = \"value\") +\n    theme_new\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-14_54f4d3040922463a68d8ef2f6bcaca60'}\n\n```{.r .cell-code}\n#ROC Plot \n\npath <- \"/StackedEnsemble_AllModels_AutoML_20200826_112031\"\n\nload_model_performance_metrics <- function(path, test_tbl) {\n    \n    model_h2o <- h2o.loadModel(path)\n    perf_h2o  <- h2o.performance(model_h2o, newdata = as.h2o(test_tbl)) \n    \n    perf_h2o %>%\n        h2o.metric() %>%\n        as_tibble() %>%\n        mutate(auc = h2o.auc(perf_h2o)) %>%\n        select(tpr, fpr, auc)\n    \n}\n\nmodel_metrics_tbl <- fs::dir_info(path = \"ml_journal-KhaledSallam/\") %>%\n    select(path) %>%\n    mutate(metrics = map(path, load_model_performance_metrics, test_tbl)) %>%\n    unnest(cols = metrics)\n\nmodel_metrics_tbl %>%\n    mutate(\n        # Extract the model names\n        path = str_split(path, pattern = \"/\", simplify = T)[,2] %>% as_factor(),\n        auc  = auc %>% round(3) %>% as.character() %>% as_factor()\n        ) %>%\n    ggplot(aes(fpr, tpr, color = path, linetype = auc)) +\n    geom_line(size = 1) +\n    \n    # just for demonstration purposes\n    geom_abline(color = \"red\", linetype = \"dotted\") +\n    \n    theme_new +\n    theme(\n      legend.direction = \"vertical\",\n      ) +\n    labs(\n        title = \"ROC Plot\",\n        subtitle = \"Performance of 3 Top Performing Models\"\n    )\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-15_203ab1a6a03f4a58f2ded33329c702fb'}\n\n```{.r .cell-code}\n# Percision vs Recall plot \n\n# Precision vs Recall\n\nload_model_performance_metrics <- function(path, test_tbl) {\n    \n    model_h2o <- h2o.loadModel(path)\n    perf_h2o  <- h2o.performance(model_h2o, newdata = as.h2o(test_tbl)) \n    \n    perf_h2o %>%\n        h2o.metric() %>%\n        as_tibble() %>%\n        mutate(auc = h2o.auc(perf_h2o)) %>%\n        select(tpr, fpr, auc, precision, recall)\n    \n}\n\nmodel_metrics_tbl <- fs::dir_info(path = \"ml_journal-KhaledSallam\") %>%\n    select(path) %>%\n    mutate(metrics = map(path, load_model_performance_metrics, test_tbl)) %>%\n    unnest(cols = metrics)\n\nmodel_metrics_tbl %>%\n    mutate(\n        path = str_split(path, pattern = \"/\", simplify = T)[,2] %>% as_factor(),\n        auc  = auc %>% round(3) %>% as.character() %>% as_factor()\n    ) %>%\n    ggplot(aes(recall, precision, color = path, linetype = auc)) +\n    geom_line(size = 1) +\n    theme_new + \n    theme(\n      legend.direction = \"vertical\",\n      ) +\n    labs(\n        title = \"Precision vs Recall Plot\",\n        subtitle = \"Performance of 3 Top Performing Models\"\n    )\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-16_386a9c0d75047eb70a73b3d87b23cf45'}\n\n```{.r .cell-code}\n# getting predictions_tbl from previous session\npredictions <- h2o.predict(stacked_ensemble_h2o, newdata = as.h2o(test_tbl))\n\ntypeof(predictions)\n# [1] \"environment\"\n\npredictions_tbl <- predictions %>% as_tibble()\n\n# No\t0.938624996\t0.06137500\t\t\n# Yes\t0.767573922\t0.23242608\t\t\n# No\t0.934670085\t0.06532991\t\t\n# Yes\t0.580364130\t0.41963587\t\t\n# Yes\t0.738244189\t0.26175581\t\t\n# Yes\t0.767517540\t0.23248246\t\t\n# Yes\t0.580365130\t0.41963487\t\t\n# No\t0.940360179\t0.05963982\t\t\n# Yes\t0.616682970\t0.38331703\t\t\n# Yes\t0.111431957\t0.88856804\t\n\n# Gain & Lift\n\nranked_predictions_tbl <- predictions_tbl %>%\n    bind_cols(test_tbl) %>%\n    select(predict:Yes, went_on_backorder) %>%\n    arrange(desc(Yes))\n\nranked_predictions_tbl\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-17_13bff179ec664616ee6a0e3d1f9d3521'}\n\n```{.r .cell-code}\n# Gain and Lift calculations \n\nranked_predictions_tbl %>%\n    mutate(ntile = ntile(Yes, n = 10)) %>%\n    group_by(ntile) %>%\n    summarise(\n        cases = n(),\n        responses = sum(went_on_backorder == \"Yes\")\n    ) %>%\n    arrange(desc(ntile))\n\ncalculated_gain_lift_tbl <- ranked_predictions_tbl %>%\n    mutate(ntile = ntile(Yes, n = 10)) %>%\n    group_by(ntile) %>%\n    summarise(\n        cases = n(),\n        responses = sum(went_on_backorder == \"Yes\")\n    ) %>%\n    arrange(desc(ntile)) %>%\n    \n    # Add group numbers (opposite of ntile)\n    mutate(group = row_number()) %>%\n    select(group, cases, responses) %>%\n    \n    # Calculations\n    mutate(\n        cumulative_responses = cumsum(responses),\n        pct_responses        = responses / sum(responses),\n        gain                 = cumsum(pct_responses),\n        cumulative_pct_cases = cumsum(cases) / sum(cases),\n        lift                 = gain / cumulative_pct_cases,\n        gain_baseline        = cumulative_pct_cases,\n        lift_baseline        = gain_baseline / cumulative_pct_cases\n    )\n\ncalculated_gain_lift_tbl \n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-18_162e85463eff29b80a87dbf1b1baea31'}\n\n```{.r .cell-code}\n# Gain Plot\n\ngain_lift_tbl <- performance_h2o %>%\n    h2o.gainsLift() %>%\n    as.tibble()\n\n## Gain Chart\n\ngain_transformed_tbl <- gain_lift_tbl %>% \n    select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift) %>%\n    select(-contains(\"lift\")) %>%\n    mutate(baseline = cumulative_data_fraction) %>%\n    rename(gain     = cumulative_capture_rate) %>%\n    # prepare the data for the plotting (for the color and group aesthetics)\n    pivot_longer(cols = c(gain, baseline), values_to = \"value\", names_to = \"key\")\n\ngain_transformed_tbl %>%\n    ggplot(aes(x = cumulative_data_fraction, y = value, color = key)) +\n    geom_line(size = 1.5) +\n    labs(\n        title = \"Gain Chart\",\n        x = \"Cumulative Data Fraction\",\n        y = \"Gain\"\n    ) +\n    theme_new\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-19_b68390231cfaa332e33aee319c9ee198'}\n\n```{.r .cell-code}\n# Lift Plot\n\nlift_transformed_tbl <- gain_lift_tbl %>% \n    select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift) %>%\n    select(-contains(\"capture\")) %>%\n    mutate(baseline = 1) %>%\n    rename(lift = cumulative_lift) %>%\n    pivot_longer(cols = c(lift, baseline), values_to = \"value\", names_to = \"key\")\n\nlift_transformed_tbl %>%\n    ggplot(aes(x = cumulative_data_fraction, y = value, color = key)) +\n    geom_line(size = 1.5) +\n    labs(\n        title = \"Lift Chart\",\n        x = \"Cumulative Data Fraction\",\n        y = \"Lift\"\n    ) +\n    theme_new\n```\n:::\n\n::: {.cell hash='04_perf_meas_cache/html/unnamed-chunk-20_9ab6f580bf625ddcf48cc367fe97b80c'}\n\n```{.r .cell-code}\n# Cowplot block\n# Visualization\n\nlibrary(cowplot)\nlibrary(glue)\n\n# set values to test the function while building it\nh2o_leaderboard <- automl_models_h2o@leaderboard\nnewdata <- test_tbl\norder_by <- \"auc\"\nmax_models <- 4\nsize <- 1\n\nplot_h2o_performance <- function(h2o_leaderboard, newdata, order_by = c(\"auc\", \"logloss\"),\n                                 max_models = 3, size = 1.5) {\n    \n    # Inputs\n    leaderboard_tbl <- h2o_leaderboard %>%\n        as_tibble() %>%\n        slice(1:max_models)\n    \n    newdata_tbl <- newdata %>%\n        as_tibble()\n    \n     # Selecting the first, if nothing is provided\n    order_by      <- tolower(order_by[[1]]) \n    \n    # Convert string stored in a variable to column name (symbol)\n    order_by_expr <- rlang::sym(order_by)\n\n    # Turn of the progress bars ( opposite h2o.show_progress())\n    h2o.no_progress()\n    \n    # 1. Model metrics\n    \n    get_model_performance_metrics <- function(model_id, test_tbl) {\n        \n        model_h2o <- h2o.getModel(model_id)\n        perf_h2o  <- h2o.performance(model_h2o, newdata = as.h2o(test_tbl))\n        \n        perf_h2o %>%\n            h2o.metric() %>%\n            as.tibble() %>%\n            select(threshold, tpr, fpr, precision, recall)\n    }\n        model_metrics_tbl <- leaderboard_tbl %>%\n        mutate(metrics = map(model_id, get_model_performance_metrics, newdata_tbl)) %>%\n        unnest(cols = metrics) %>%\n        mutate(\n          model_id = as_factor(model_id) %>% \n                      # programmatically reorder factors depending on order_by\n                      fct_reorder(!! order_by_expr, \n                                  .desc = ifelse(order_by == \"auc\", TRUE, FALSE)),\n          auc      = auc %>% \n                      round(3) %>% \n                      as.character() %>% \n                      as_factor() %>% \n                      fct_reorder(as.numeric(model_id)),\n          logloss  = logloss %>% \n                      round(4) %>% \n                      as.character() %>% \n                      as_factor() %>% \n                      fct_reorder(as.numeric(model_id))\n        )\n    \n    \n    # 1A. ROC Plot\n    \n    p1 <- model_metrics_tbl %>%\n        ggplot(aes(fpr, tpr, color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size) +\n        theme_new +\n        labs(title = \"ROC\", x = \"FPR\", y = \"TPR\") +\n        theme(legend.direction = \"vertical\") \n        \n    \n    # 1B. Precision vs Recall\n    \n    p2 <- model_metrics_tbl %>%\n        ggplot(aes(recall, precision, color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size) +\n        theme_new +\n        labs(title = \"Precision Vs Recall\", x = \"Recall\", y = \"Precision\") +\n        theme(legend.position = \"none\") \n    \n    \n    # 2. Gain / Lift\n    \n    get_gain_lift <- function(model_id, test_tbl) {\n        \n        model_h2o <- h2o.getModel(model_id)\n        perf_h2o  <- h2o.performance(model_h2o, newdata = as.h2o(test_tbl)) \n        \n        perf_h2o %>%\n            h2o.gainsLift() %>%\n            as.tibble() %>%\n            select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift)\n        \n    }\n    \n    gain_lift_tbl <- leaderboard_tbl %>%\n        mutate(metrics = map(model_id, get_gain_lift, newdata_tbl)) %>%\n        unnest(cols = metrics) %>%\n        mutate(\n            model_id = as_factor(model_id) %>% \n                fct_reorder(!! order_by_expr, \n                            .desc = ifelse(order_by == \"auc\", TRUE, FALSE)),\n            auc  = auc %>% \n                round(3) %>% \n                as.character() %>% \n                as_factor() %>% \n                fct_reorder(as.numeric(model_id)),\n            logloss = logloss %>% \n                round(4) %>% \n                as.character() %>% \n                as_factor() %>% \n                fct_reorder(as.numeric(model_id))\n        ) %>%\n        rename(\n            gain = cumulative_capture_rate,\n            lift = cumulative_lift\n        ) \n    \n    # 2A. Gain Plot\n    \n    p3 <- gain_lift_tbl %>%\n        ggplot(aes(cumulative_data_fraction, gain, \n                          color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size,) +\n        geom_segment(x = 0, y = 0, xend = 1, yend = 1, \n                     color = \"red\", size = size, linetype = \"dotted\") +\n        theme_new +\n        expand_limits(x = c(0, 1), y = c(0, 1)) +\n        labs(title = \"Gain\",\n             x = \"Cumulative Data Fraction\", y = \"Gain\") +\n        theme(legend.position = \"none\")\n    \n    # 2B. Lift Plot\n    \n    p4 <- gain_lift_tbl %>%\n        ggplot(aes(cumulative_data_fraction, lift, \n                          color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size) +\n        geom_segment(x = 0, y = 1, xend = 1, yend = 1, \n                     color = \"red\", size = size, linetype = \"dotted\") +\n        theme_new +\n        expand_limits(x = c(0, 1), y = c(0, 1)) +\n        labs(title = \"Lift\",\n             x = \"Cumulative Data Fraction\", y = \"Lift\") +\n        theme(legend.position = \"none\") \n    \n    \n    # Combine using cowplot\n    \n    # cowplot::get_legend extracts a legend from a ggplot object\n    p_legend <- get_legend(p1)\n    # Remove legend from p1\n    p1 <- p1 + theme(legend.position = \"none\")\n    \n    # cowplot::plt_grid() combines multiple ggplots into a single cowplot object\n    p <- cowplot::plot_grid(p1, p2, p3, p4, ncol = 2)\n    \n    # cowplot::ggdraw() sets up a drawing layer\n    p_title <- ggdraw() + \n    \n        # cowplot::draw_label() draws text on a ggdraw layer / ggplot object\n        draw_label(\"H2O Model Metrics\", size = 18, fontface = \"bold\", \n                   color = \"#2C3E50\")\n    \n    p_subtitle <- ggdraw() + \n        draw_label(glue(\"Ordered by {toupper(order_by)}\"), size = 10,  \n                   color = \"#2C3E50\")\n    \n    # Combine everything\n    ret <- plot_grid(p_title, p_subtitle, p, p_legend, \n    \n                     # Adjust the relative spacing, so that the legends always fits\n                     ncol = 1, rel_heights = c(0.05, 0.05, 1, 0.05 * max_models))\n    \n    h2o.show_progress()\n    \n    return(ret)\n    \n}\n\nautoml_models_h2o@leaderboard %>%\n    plot_h2o_performance(newdata = test_tbl, order_by = \"logloss\", \n                         size = 0.5, max_models = 4)\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}